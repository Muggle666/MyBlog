## What:

装饰者模式又名包装(Wrapper)模式。装饰者模式动态地将责任附加到对象身上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

## Why:
**优点：**
1.装饰者模式比继承灵活性，在不改变原有对象的情况下给对象扩展功能，符合开闭原则。
>继承关系是静态的，在编译的时候就已经决定了行为，不便于控制增加行为的方式和时机。

2.装饰者模式可以动态使用不同的装饰类排列组合，创造出多样的行为组合。

**缺点：**
>1.装饰模式会导致设计出大量的ConcreteDecorator类，增加系统的复杂性。
>2.对于多次装饰的对象，一旦出现错误，排错繁琐；

## Where:

>1.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
>2.需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。  
>3.当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。

## How:

在学习使用装饰者模式之前，先了解几个重要角色。

**Component（抽象构件）**：定义需要实现业务的抽象方法。

**ConcreteComponent（具体构件）**：实现Component接口，用于定义具体的构建对象，可以给它增加额外的职责（方法）。

**Decorator（抽象装饰类）**：实现Component接口，并创建Component实例对象。用于给具体构件(ConcreteComponent)增加职责。

**ConcreteDecorator（具体装饰类）**：抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。

![装饰者模式UML](https://raw.githubusercontent.com/MuggleLee/PicGo/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/Pattern-Decorator.png)


示例：以点餐为例，我在麦*劳点餐可以根据我需求增加食物种类和数量。




























# 总结



参考资料：
[https://blog.csdn.net/wwwdc1012/article/details/82764333](https://blog.csdn.net/wwwdc1012/article/details/82764333)