到此为止，是否觉得写的单例模式完美无缺了呢？接下来看一下的示例代码：

饿汉模式：

```java
public class HungrySingleton implements Serializable {

    private final static HungrySingleton hungrySingleton = new HungrySingleton();

    private HungrySingleton() {

    }

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }
    
}

```
```java
public class test {

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        HungrySingleton instance = HungrySingleton.getInstance();

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("singleton_file"));
        oos.writeObject(instance);

        File file = new File("singleton_file");
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));

        HungrySingleton newInstance = (HungrySingleton) ois.readObject();

        System.out.println(instance);
        System.out.println(newInstance);
        System.out.println(instance == newInstance);

    }

}
```
输出结果：
```java
SingletonPattern.HungrySingleton@7f31245a
SingletonPattern.HungrySingleton@568db2f2
false
```
由输出结果可以看出，通过序列化和反序列化之后两个的对象是不一样的，这也违背了单例模式的初衷。但为什么会这样呢？接下来通过查看源码去解决问题！

我猜测是反序列化的时候执行了什么代码重新