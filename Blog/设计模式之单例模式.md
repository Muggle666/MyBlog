# 定义
> 保证一个类只有一个实例，并提供全局访问点。

# 使用场景
1. 要求生产唯一序列号。
2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

如何写出一个线程安全的单例模式呢？其实很简单，使用synchronized加锁和使用volatile防止重排序。

### 懒汉模式 vs 饿汉模式
懒汉模式：很懒。在调用的时候才会创建单例。(延迟加载)
饿汉模式：很饿。在系统加载的时候就会创建单例。(预加载)

示例：
```java
/**
 * 懒汉模式
 */
1. public class LazySingleton {
2. 
3.     private static LazySingleton lazySingleton = null;
4. 
5.     private LazySingleton() {
6.     }
7. 
8.     public static LazySingleton getInstance() {
9.         if (lazySingleton == null) {
10.             lazySingleton = new LazySingleton();
11.         }
12.         return lazySingleton;
13.     }
14. }
```

```java
/**
 * 饿汉模式
 */
1. public class HungrySingleton implements Serializable {
2. 
3.     private final static HungrySingleton hungrySingleton = new HungrySingleton();
4. 
5.     private HungrySingleton() {
6.     }
7. 
8.     public static HungrySingleton getInstance() {
9.         return hungrySingleton;
10.     }
11. }
```
以上两种代码在单线程的情况下是没问题的，但懒汉模式在多线程的情况就会有可能出现问题。
<font color="red">*在重现问题之前，首先要学会多线程debug。</font>可以参考[idea 多线程debug](https://blog.csdn.net/kevindai007/article/details/71412324)

先写一个简单的线程类：
```java
1. public class ThreadDemo implements Runnable{
2.     @Override
3.     public void run() {
4.         LazySingleton lazySingleton = LazySingleton.getInstance();
5.         System.out.println(Thread.currentThread().getName() + "  " + lazySingleton);
6.     }
7. }

```
```java
1. public class Main {
2.     public static void main(String[] args) {
3.         new Thread(new ThreadDemo()).start();
4.         new Thread(new ThreadDemo()).start();
5.         System.out.println(Thread.currentThread().getName() + "  " + "is Done!" );
6.     }
7. }
```
首先在ThreadDemo中



双重检验加锁机制


到此为止，是否觉得写的单例模式完美无缺了呢？接下来看一下的示例代码：


```java
public class SerializableSingleton {
    private final static SerializableSingleton serializableSingleton = new SerializableSingleton();

    private SerializableSingleton() {
  }

    public static SerializableSingleton getInstance() {
        return serializableSingleton;
    }
}

```
```java
public class SerializableSingletonTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        SerializableSingleton instance = SerializableSingleton.getInstance();

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("SingletonTest"));
        oos.writeObject(instance);

        File file = new File("SingletonTest");
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
	//反序列化获取SerializableSingleton对象
        SerializableSingleton newInstance = (SerializableSingleton) ois.readObject();

        System.out.println(instance);
        System.out.println(newInstance);
        System.out.println(instance == newInstance);
    }
}
```
输出结果：
```java
SingletonPattern.HungrySingleton@7f31245a
SingletonPattern.HungrySingleton@568db2f2
false
```
由输出结果可以看出，通过序列化和反序列化之后两个的对象是不一样的，这也违背了单例模式的初衷。但为什么会这样呢？我猜测是反序列化的时候执行了什么代码重新创建对象导致的。接下来通过查看源码去验证我的猜测。

反序列化是通过ObjectInputStream类的readObject方法实现的，那就直接打开readObject方法撸源码吧！
```java
public final Object readObject() throws IOException, ClassNotFoundException{

	//为省篇幅，省略部分代码
        try {
            Object obj = readObject0(false);
            //为省篇幅，省略部分代码
            return obj;
        } 
	//为省篇幅，省略部分代码
    }
```
readObject方法返回Object对象，那Object obj = readObject0(false);这一行代码返回的就是反序列化对象咯，那打开readObject0()方法查看里面有什么乾坤...
```java
    /**
     * Underlying readObject implementation.
     */
    private Object readObject0(boolean unshared) throws IOException {

        //为省篇幅，省略部分代码

        try {
            switch (tc) {

                //为省篇幅，省略部分代码

                case TC_OBJECT:
                    return checkResolve(readOrdinaryObject(unshared));

                //为省篇幅，省略部分代码
            }
        } 
	//为省篇幅，省略部分代码	
    }
```
由方法的注释就知道这个方法是反序列化的实现方法。因为我传进去的是Object对象，所以重点看return checkResolve(readOrdinaryObject(unshared));这一行。
```java
private Object readOrdinaryObject(boolean unshared) throws IOException{
        
	//为省篇幅，省略部分代码
	
        Object obj;
        try {
            obj = desc.isInstantiable() ? desc.newInstance() : null;
        } catch (Exception ex) {
            throw (IOException) new InvalidClassException(
                desc.forClass().getName(),
                "unable to create instance").initCause(ex);
        }

        //为省篇幅，省略部分代码

        if (obj != null &&
            handles.lookupException(passHandle) == null &&
            desc.hasReadResolveMethod())
        {
            Object rep = desc.invokeReadResolve(obj);
            if (unshared && rep.getClass().isArray()) {
                rep = cloneArray(rep);
            }
            if (rep != obj) {
                // Filter the replacement object
                if (rep != null) {
                    if (rep.getClass().isArray()) {
                        filterCheck(rep.getClass(), Array.getLength(rep));
                    } else {
                        filterCheck(rep.getClass(), -1);
                    }
                }
                handles.setObject(passHandle, obj = rep);
            }
        }

        return obj;
    }

```

由于readOrdinaryObject方法返回的是Object对象，所以根据源码，Object对象的声明就在obj = desc.isInstantiable() ? desc.newInstance() : null这一行，我是不是离真相越来越近了呢？接下来继续看isInstantiable源码。
```java
    /**
     * Returns true if represented class is serializable/externalizable and can
     * be instantiated by the serialization runtime--i.e., if it is
     * externalizable and defines a public no-arg constructor, or if it is
     * non-externalizable and its first non-serializable superclass defines an
     * accessible no-arg constructor.  Otherwise, returns false.
     */
    boolean isInstantiable() {
        requireInitialized();
        return (cons != null);
    }
```
根据方法的注释可知，如果一个实现了序列化的类在运行的时候被实例化，那就返回true，所以就会执行desc.newInstance()，这个方法就会通过反射调用无参的构造方法创建一个新的对象。所以问题就是在这里，通过反射返回一个新对象。那有什么办法解决呢？
继续看readOrdinaryObject方法的源码，其中obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()就是解决问题的所在。
```java
    /**
     * Returns true if represented class is serializable or externalizable and
     * defines a conformant readResolve method.  Otherwise, returns false.
     */
    boolean hasReadResolveMethod() {
        requireInitialized();
        return (readResolveMethod != null);
    }
```
根据方法注释，我可以知道如果一个类是可序列化或可反序列化的，并且定义了一个方法名为readResolve就会返回true。如果obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()判断返回true就会往下执行Object rep = desc.invokeReadResolve(obj)

invokeReadResolve方法通过反射的方式调用反序列化的类中定义的readResolve方法，并且赋值给返回的变量obj。

因此可以猜测，只要在序列化、反序列化中的类定义了readResolve方法就可以解决单例模式序列化与反序列化对象不一致的问题。

改进版SerializableSingleton类：
```java
public class SerializableSingleton implements Serializable {
    private final static SerializableSingleton serializableSingleton = new SerializableSingleton();

    private SerializableSingleton() {

    }

    public static SerializableSingleton getInstance() {
        return serializableSingleton;
    }

    private Object readResolve(){
        return serializableSingleton;
    }
}
```
```java
public class SerializableSingletonTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        SerializableSingleton instance = SerializableSingleton.getInstance();

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("SingletonTest"));
        oos.writeObject(instance);

        File file = new File("SingletonTest");
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));

        SerializableSingleton newInstance = (SerializableSingleton) ois.readObject();

        System.out.println(instance);
        System.out.println(newInstance);
        System.out.println(instance == newInstance);

    }
}

```
运行结果：
```java
SingletonPattern.SerializableSingleton@7f31245a
SingletonPattern.SerializableSingleton@7f31245a
true
```
结论：
> 在设计单例模式的时候，一定要考虑类是否需要序列化，如果需要序列化则需要添加readResolve方法返回单例对象。