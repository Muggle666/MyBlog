# 设计模式之桥接模式
## What:

>将抽象部分与它的实现部分分离，使它们都可以独立地变化。


## Why:
#### 优点：
>1.抽象和实现的分离。 
2.优秀的扩展能力。 
3.实现细节对客户透明。

#### 缺点：
>1.增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程。
2.要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性。

## Where:
>1.一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；
2.对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

## How:

桥接模式有以下几种角色：

**抽象化角色(Abstraction)：** 抽象化给出的定义，并保存一个对实现化对象的引用。

**修正抽象化角色(RefineAbstraction)：** 拓展抽象化角色，改变和修正父类对抽象化的定义。

**实现化角色(Implementor)：** 这个角色给出实现化角色的接口，但是不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。

**具体实现化角色(ConcreteImplementor)：** 这个角色给出实现化角色接口的具体实现。

示例：家电电器有很多种，也有很多品牌，电器和品牌存在关系。

---图片

如图所示，如果按照这样的设计，每增加一种电器就需要对应的绑定品牌；另一种情况是，每增加一个品牌就需要在对应的电器下添加。这样的话会导致出现许多重复性的代码，而且耦合度也很高。

如果添加新的品牌或者新的电器而不会改动先有的类，该怎么设计呢？

如下图所示：


ElectricAppliance接口：
```java
public interface ElectricAppliance {
    String description();
}
```
AirConditioner类、Refrigerator类、WashingMachine类、WaterHeater类：
```java
public class AirConditioner implements ElectricAppliance {

    private final String name = "空调";

    @Override
    public String description() {
        return name;
    }
}
public class Refrigerator implements ElectricAppliance{

    private final String name = "冰箱";

    @Override
    public String description() {
        return name;
    }
}
public class WashingMachine implements ElectricAppliance {

    private final String name = "洗衣机";

    @Override
    public String description() {
        return name;
    }
}
public class WaterHeater implements ElectricAppliance {

    private final String name = "热水器";

    @Override
    public String description() {
        return name;
    }
}
```
Brandch


Test:测试类
```java

```
输出结果：
```java

```



# 总结

参考资料:
[https://www.cnblogs.com/lixiuyu/p/5923160.html](https://www.cnblogs.com/lixiuyu/p/5923160.html)
[https://www.jianshu.com/p/775cb53a4da2](https://www.jianshu.com/p/775cb53a4da2)