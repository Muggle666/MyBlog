# 设计模式之建造者模式

## What:
建造者模式是将一个复杂的**对象的构建与表示**分离，使得同样的构建过程可以创建不同的表示。建造者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。

## Why:
优点：
1.遵循开闭原则。
2.对象的建造和表示分离，实现了解耦。
3.隐藏了对象的建造细节，用户只需关心产品的表示，而不需要了解是如何创建产品的。
缺点：
1.如果构造者多，会有很多的建造类，难以维护。
2.产品的组成部分必须相同，这限制了其使用范围。
## Where:
1.隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果
2.需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

## How:

在学习使用建造者模式之前，我们需要了解几个概念。

#### Product：具体的产品。
#### Builder：抽象的建造方法。
#### ConcreteBuilder：具体的建造者。
#### Director(指挥官)：调用具体构造者创建的产品对象，负责将客户端传来指令交给具体的建造者。

![建造者模式UML](https://raw.githubusercontent.com/MuggleLee/PicGo/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/Pattern-Builder.png)

ComputerDIY类：具体的对象
```java
/**
 * 组装电脑需要的元件
 */
public class ComputerDIY {

    private String CPU;
    private String mainboard;
    private String memory;
    private String SSD;
    private String power;

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("电脑配置如下：\n");
        sb.append("CPU：")
                .append(CPU).append('\n');
        sb.append("主板:\"")
                .append(mainboard).append('\n');
        sb.append("内存：")
                .append(memory).append('\n');
        sb.append("SSD：")
                .append(SSD).append('\n');
        sb.append("电源：")
                .append(power).append('\n');
        return sb.toString();
    }

    // 省略get、set方法
    
}
```
ComputerBuilder：抽象的建造方法
```java
/**
 * 组装电脑抽象建造者
 */
public abstract class ComputerBuilder {

    public abstract void buildCPU(String CPU);

    public abstract void buildMainboard(String mainboard);

    public abstract void buildMemory(String memory);

    public abstract void buildSSD(String SSD);

    public abstract void buildPower(String power);

    public abstract ComputerDIY build();

}
```


# 总结